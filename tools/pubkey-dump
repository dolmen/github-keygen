#!/usr/bin/env perl

# Decode OpenSSH public key string into structured data.
# The data and encoding depends on the key type.
#
# Usage: pubkey-dump ~/.ssh/id_rsa.pub
# Usage: pubkey-dump ~/.ssh/known_hosts
# Usage: pubkey-dump ~/.ssh/authorized_keys

use strict;
use warnings;
use feature 'say';

use MIME::Base64 ();

my %decoders = (
    'ssh-rsa' => sub {
        my ($exp, $mod, $rem) = unpack('(N/a)2 a*', $_[0]);
	# Why $mod starts with an additional byte that is always zero?
	my $bits = ((length $mod)-1)*8;
        sprintf("bits: %d\nexponent: %v02X\nmodulus: %v02X\n", $bits, $exp, $mod)
        . (length($rem) ? sprintf("other: %v02X\n", $rem) : '')
    },
    'ssh-ed25519' => sub {
	# Skip 4 first bytes (00.00.00.20)
	# Show the other 32 bytes as hex
	sprintf("pk: %v02X\n", substr($_[0], 4))
    },
    # TODO: add other key types
);


open my $f, '<', $ARGV[0] or die;
while (<$f>) {
    next if /^#/;
    if (/^[^ ]+ +ssh-/) { # Allow to also decode known_hosts: move hostname to the end of the line
	s/^([^ ]*) +(ssh-.*)$/$2 $1/;
    }
    my ($b64) = $_ =~ m!^[^ ]+ ([0-9a-zA-Z+/]+=*)( |$)! or die "unexpected line format: \"$_\"";
    my $bytes = MIME::Base64::decode($b64);
    my ($type, $remain) = unpack('N/a a*', $bytes);
    unless ($decoders{$type}) {
	printf STDERR "unknown key type $type\n";
	next
    }
    printf "type: %s\nlength: %d\nraw: %v02X\n%s", $type, length $remain, $remain, $decoders{$type}->($remain);
}

close $f;
