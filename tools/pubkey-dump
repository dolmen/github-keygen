#!/usr/bin/env perl

# Decode OpenSSH public key string into structured data.
# The data and encoding depends on the key type.
#
# Usage: pubkey-dump ~/.ssh/id_rsa.pub
# Usage: pubkey-dump ~/.ssh/known_hosts
# Usage: pubkey-dump ~/.ssh/authorized_keys
#
# See also:
#   ssh-keygen -e -m PEM -f id_rsa
#   ssh-keygen -e -m PEM -f id_rsa.pub
#
# References:
#   https://www.rfc-editor.org/rfc/rfc4716.html#section-3.4

use strict;
use warnings;
use feature 'say';

use MIME::Base64 ();
use Math::BigInt ();

my %decoders = (
    # References:
    #  https://www.rfc-editor.org/rfc/rfc4253.html#section-6.6
    #  https://www.rfc-editor.org/rfc/rfc4251.html#section-5
    'ssh-rsa' => sub {
	require 'Math/BigInt.pm';
        my ($exp, $mod, $rem) = unpack('(N/a)2 a*', $_[0]);
	my $len = length $mod;
	my $bits = (substr($mod, 0, 1) == 0 ? $len-1 : $len )*8;
        sprintf("bits: %d\nexponent-mpint-hex: %v02X\nmodulus-mpint-hex: %v02X\nmodulus: %s\n", $bits, $exp, $mod, Math::BigInt->new(sprintf "0x%*v02X", '', substr($mod, 1)))
        . (length($rem) ? sprintf("other: %v02X\n", $rem) : '')
    },
    'ssh-ed25519' => sub {
	# Skip 4 first bytes (00.00.00.20)
	# Show the other 32 bytes as hex
	sprintf("pk: %v02X\n", substr($_[0], 4))
    },
    # TODO: add other key types
);


open my $f, '<', $ARGV[0] or die;
while (<$f>) {
    next if /^#/;
    if (/^[^ ]+ +ssh-/) { # Allow to also decode known_hosts: move hostname to the end of the line
	s/^([^ ]*) +(ssh-.*)$/$2 $1/;
    }
    my ($b64) = $_ =~ m!^[^ ]+ ([0-9a-zA-Z+/]+=*)( |$)! or die "unexpected line format: \"$_\"";
    my $bytes = MIME::Base64::decode($b64);
    my ($type, $remain) = unpack('N/a a*', $bytes);
    unless ($decoders{$type}) {
	printf STDERR "unknown key type $type\n";
	next
    }
    printf "type: %s\nlength: %d\nraw: %v02X\n%s", $type, length $remain, $remain, $decoders{$type}->($remain);
}

close $f;
